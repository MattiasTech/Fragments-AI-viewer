<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>That Open • Components Viewer (IFC + FRAG)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- One CDN + pinned, compatible versions -->
 <script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.175.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.175.0/examples/jsm/",

    "@thatopen/components":        "https://cdn.jsdelivr.net/npm/@thatopen/components@3.1.2/dist/index.mjs",
    "@thatopen/fragments":         "https://cdn.jsdelivr.net/npm/@thatopen/fragments@3.1.7/dist/index.mjs",
    "@thatopen/components-front":  "https://cdn.jsdelivr.net/npm/@thatopen/components-front@3.1.3/dist/index.js",

    "@thatopen/ui":     "https://cdn.jsdelivr.net/npm/@thatopen/ui@3.1.3/dist/index.js",
    "@thatopen/ui-obc": "https://cdn.jsdelivr.net/npm/@thatopen/ui-obc@3.1.5/dist/index.js",

    "web-ifc": "https://cdn.jsdelivr.net/npm/web-ifc@0.0.69/web-ifc-api.js"
  }
}
</script>
  <style>
    :root { --bg:#0c0f14; --fg:#e6eefc; --panel:#0b1120; --border:#1f2a44; }
    html, body { height:100%; margin:0; }
    body { background:var(--bg); color:var(--fg); font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }

    header { position:fixed; inset:0 0 auto 0; display:flex; gap:.5rem; align-items:center;
             padding:.5rem .75rem; background:var(--panel); border-bottom:1px solid var(--border); z-index:10 }
    header .spacer { flex:1 }
    header .btn { cursor:pointer; border:1px solid #2a3a64; background:#121a2b; color:#cde; padding:.3rem .55rem; border-radius:.35rem; }
    input[type=file] { display:none }

    #stage { position:fixed; inset:40px 0 0 0; }
    #container { width:100%; height:100%; }
    #dropzone { position:absolute; inset:0; border:2px dashed rgba(255,255,255,.25);
                display:grid; place-items:center; pointer-events:none; opacity:0; transition:.2s; }
    #dropzone.active { opacity:1; background:rgba(0,0,0,.25); }

    /* Panel placement */
    bim-panel.viewer-panel { position:fixed; left:12px; top:56px; max-width:380px; z-index:11 }
  </style>
</head>
<body>
  <header>
    <strong>That Open • Components Viewer</strong>
    <span class="spacer"></span>
    <label class="btn">
      <input id="file" type="file" accept=".ifc,.IFC,.frag,.FRAG" />
      Open IFC/FRAG…
    </label>
    <a class="btn" target="_blank" rel="noopener" href="https://github.com/ThatOpen/engine_components">engine_components</a>
  </header>

  <div id="stage">
    <div id="container"></div>
    <div id="progress" style="position:fixed;left:50%;transform:translateX(-50%);bottom:18px;width:60%;max-width:720px;z-index:20;display:none">
      <div style="background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.06);padding:6px;border-radius:6px;">
        <div id="progressBarWrap" style="background:rgba(0,0,0,.25);height:12px;border-radius:4px;overflow:hidden">
          <div id="progressBar" style="width:0%;height:100%;background:linear-gradient(90deg,#3aa1ff,#66ffb3);transition:width .15s ease"></div>
        </div>
        <div id="progressLabel" style="margin-top:6px;color:var(--fg);font-size:12px;text-align:center">Waiting</div>
      </div>
    </div>
    <div id="dropzone"><div style="color:#fff;font:600 16px system-ui">Drop IFC or FRAG here</div></div>
  </div>

  <!-- Optional: offline shell caching if you have sw.js -->
  <script>
    if ('serviceWorker' in navigator) navigator.serviceWorker.register('./sw.js').catch(()=>{});
  </script>

  <script type="module">
    import * as THREE from "three";
    import * as OBC   from "@thatopen/components";
    import * as FRAGS from "@thatopen/fragments";
    import * as BUI     from "@thatopen/ui";
    import * as BUIOBC  from "@thatopen/ui-obc";

    // -------- Components world (scene/camera/renderer) --------
    const components = new OBC.Components();
    const worlds = components.get(OBC.Worlds);
    const world  = worlds.create(OBC.SimpleScene, OBC.SimpleCamera, OBC.SimpleRenderer);

    const container = document.getElementById("container");
    world.renderer = new OBC.SimpleRenderer(components, container);
    world.scene    = new OBC.SimpleScene(components);
    world.camera   = new OBC.SimpleCamera(components);
    world.scene.setup();
    world.camera.controls.setLookAt(60, 25, -30, 0, 0, 0);

    const grids = components.get(OBC.Grids);
    grids.create(world);

    await components.init();

    // -------- .FRAG loader (Fragments runtime) --------
    // Use the official worker (wrap in Blob URL for cross-origin safety on Pages)
    const workerBlob = await (await fetch("https://thatopen.github.io/engine_fragment/resources/worker.mjs")).blob();
    const workerUrl = URL.createObjectURL(new File([workerBlob], "worker.mjs", { type: "text/javascript" }));
    const fragRuntime = new FRAGS.FragmentsModels(workerUrl);

    // Keep Fragments interactions in sync with the Components camera
    if (world && world.camera?.controls && typeof world.camera.controls.addEventListener === 'function') {
      world.camera.controls.addEventListener("rest", () => fragRuntime.update(true));
    } else {
      console.warn('camera.controls not available; skipping sync for fragRuntime.update on rest event');
    }

    // When a FRAG model is loaded, attach it to the Components world
    if (fragRuntime.models && fragRuntime.models.list && typeof fragRuntime.models.list.onItemSet?.add === 'function') {
      fragRuntime.models.list.onItemSet.add(({ value: model }) => {
      model.useCamera(world.camera.three);
      world.scene.three.add(model.object);
      fitView();
      fragRuntime.update(true);
      updateStats();
    });
    } else {
      console.warn('fragRuntime.models.list.onItemSet.add not available; FRAG model attach events may not be reported');
    }

    // -------- IFC loader (browser-only conversion) --------
    const ifcLoader = components.get(OBC.IfcLoader);
    ifcLoader.settings.wasm = { absolute: true, path: "https://cdn.jsdelivr.net/npm/web-ifc@0.0.69/" };
    // Progress UI helpers
    const progressRoot = document.getElementById('progress');
    const progressBar = document.getElementById('progressBar');
    const progressLabel = document.getElementById('progressLabel');
    function showProgress(label = 'Loading…') { progressRoot.style.display = 'block'; progressBar.style.width = '0%'; progressLabel.textContent = label; }
    function updateProgress(p, label) { const pct = Math.max(0, Math.min(100, Math.round(p * 100))); progressBar.style.width = pct + '%'; if (label) progressLabel.textContent = label; }
    function hideProgress() { progressBar.style.width = '100%'; setTimeout(() => { progressRoot.style.display = 'none'; progressBar.style.width = '0%'; progressLabel.textContent = 'Waiting'; }, 300); }

    // Some builds of the IfcLoader may not expose an `onProgress` event object.
    // If available, wire it to the progress UI; otherwise fall back to simple console logging.
    if (ifcLoader.onProgress && typeof ifcLoader.onProgress.add === 'function') {
      ifcLoader.onProgress.add((p) => {
        // p may be a number 0-1 or an object with loaded/total
        if (typeof p === 'number') {
          showProgress('Loading IFC…');
          updateProgress(p, `Loading IFC… ${Math.round(p * 100)}%`);
          if (p >= 1) hideProgress();
        } else if (p && typeof p.loaded === 'number' && typeof p.total === 'number') {
          showProgress('Loading IFC…');
          updateProgress(p.loaded / p.total, `Loading IFC… ${Math.round((p.loaded / p.total) * 100)}%`);
          if (p.loaded >= p.total) hideProgress();
        } else {
          console.log('IFC→Fragments progress:', p);
        }
      });
    } else {
      console.warn('ifcLoader.onProgress is not available; IFC load progress will not be reported.');
    }

    // -------- UI: That Open UI + OBC bindings --------
    BUI.Manager.init();
    BUIOBC.setComponents(components);

    const [panel] = BUI.Component.create(BUI.Panel, () => BUI.html`
      <bim-panel class="viewer-panel" label="Viewer Controls" active>
        <bim-panel-section label="Load">
          <bim-label style="white-space:normal">
            Open an <b>IFC</b> (converted locally) or a prebuilt <b>FRAG</b> file.
          </bim-label>
          <bim-toolbar>
            <bim-toolbar-group>
              <bim-button id="openBtn" icon="mdi:file-upload">Open IFC/FRAG…</bim-button>
            </bim-toolbar-group>
          </bim-toolbar>
        </bim-panel-section>

        <bim-panel-section label="Navigation">
          <bim-toolbar>
            <bim-toolbar-group>
              <bim-button id="fitBtn"  icon="mdi:focus-field">Fit to model</bim-button>
              <bim-button id="homeBtn" icon="mdi:undo-variant">Reset view</bim-button>
            </bim-toolbar-group>
            <bim-toolbar-group>
              <bim-selector id="projSel" label="Projection" value="persp">
                <bim-option value="persp">Perspective</bim-option>
                <bim-option value="ortho">Orthographic</bim-option>
              </bim-selector>
              <bim-checkbox id="gridCbx" label="Grid" checked></bim-checkbox>
              <bim-checkbox id="wireCbx" label="Wireframe"></bim-checkbox>
            </bim-toolbar-group>
          </bim-toolbar>
        </bim-panel-section>

        <bim-panel-section label="Stats">
          <bim-label id="statsLabel">Meshes: 0 • Tris: 0</bim-label>
        </bim-panel-section>
      </bim-panel>
    `);
    document.body.append(panel);

    // UI refs
    const fileInput  = document.getElementById("file");
    const openBtn    = panel.querySelector("#openBtn");
    const fitBtn     = panel.querySelector("#fitBtn");
    const homeBtn    = panel.querySelector("#homeBtn");
    const projSel    = panel.querySelector("#projSel");
    const gridCbx    = panel.querySelector("#gridCbx");
    const wireCbx    = panel.querySelector("#wireCbx");
    const statsLabel = panel.querySelector("#statsLabel");

    openBtn.addEventListener("click", () => fileInput.click());
    fitBtn.addEventListener("click", fitView);
    homeBtn.addEventListener("click", () => { world.camera.controls.reset(true); fitView(); });
    projSel.addEventListener("change", (e) => setProjection(e.target.value));
    gridCbx.addEventListener("change", (e) => grids.list.get(world)?.forEach(g => g.visible = e.target.checked));
    wireCbx.addEventListener("change", (e) => setWireframe(e.target.checked));

    // -------- File input & Drag-and-drop (.ifc or .frag) --------
    fileInput.addEventListener("change", async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      await openFile(file);
      fileInput.value = "";
    });

    const stage = document.getElementById("stage");
    const dropzone = document.getElementById("dropzone");
    ["dragenter","dragover"].forEach(ev => stage.addEventListener(ev, (e) => {
      e.preventDefault(); dropzone.classList.add("active");
    }));
    ["dragleave","drop"].forEach(ev => stage.addEventListener(ev, (e) => {
      e.preventDefault(); dropzone.classList.remove("active");
    }));
    stage.addEventListener("drop", async (e) => {
      const file = e.dataTransfer?.files?.[0];
      if (file) await openFile(file);
    });

    async function openFile(file) {
      if (/\.frag$/i.test(file.name)) {
        await loadFRAG(file);
      } else if (/\.ifc$/i.test(file.name)) {
        await loadIFC(file);
      } else {
        alert("Please select an .ifc or .frag file.");
      }
    }

    async function loadIFC(file) {
      // Show indeterminate progress while converting/loading
      try {
        showProgress('Converting IFC…');
      } catch (e) {}
      // Components IfcLoader: converts IFC→Fragments and returns a model
      try {
        const model = await ifcLoader.load(file);
        model.useWorld(world);
        world.scene.three.add(model.object);
        fitView();
        updateStats();
      } finally {
        try { hideProgress(); } catch (e) {}
      }
    }

    async function loadFRAG(file) {
      try { showProgress('Loading FRAG…'); } catch (e) {}
      try {
        const buffer = await file.arrayBuffer();
        const name = file.name.replace(/\.[^/.]+$/, "");
        const model = await fragRuntime.load(buffer, { modelId: name });
        model.useCamera(world.camera.three);
        world.scene.three.add(model.object);
        fitView();
        fragRuntime.update(true);
        updateStats();
      } finally {
        try { hideProgress(); } catch (e) {}
      }
    }

    // -------- Viewer utilities --------
    function sceneBounds() {
      const box = new THREE.Box3();
      box.expandByObject(world.scene.three);
      return box;
    }

    function fitView() {
      const box = sceneBounds();
      if (box.isEmpty()) return;
      const size   = box.getSize(new THREE.Vector3()).length();
      const center = box.getCenter(new THREE.Vector3());
      const fitDist = Math.max(size * 1.1, 10);
      const dir = new THREE.Vector3(1, 0.6, -1).normalize();
      const cam = world.camera.three;

      cam.position.copy(center.clone().add(dir.multiplyScalar(fitDist)));
      world.camera.controls.setLookAt(cam.position.x, cam.position.y, cam.position.z, center.x, center.y, center.z, true);
      cam.near = Math.max(0.1, size / 1000);
      cam.far  = Math.max(2000, size * 5);
      cam.updateProjectionMatrix();
    }

    function setProjection(mode) {
      if (mode === "persp") world.camera.setProjection("perspective");
      if (mode === "ortho") world.camera.setProjection("orthographic");
    }

    function setWireframe(on) {
      world.scene.three.traverse(obj => {
        if (obj.isMesh && obj.material) {
          if (Array.isArray(obj.material)) obj.material.forEach(m => m.wireframe = on);
          else obj.material.wireframe = on;
        }
      });
    }

    function updateStats() {
      let meshes = 0, tris = 0;
      world.scene.three.traverse(o => {
        if (o.isMesh && o.geometry) {
          meshes++;
          const triCount = o.geometry.index
            ? o.geometry.index.count / 3
            : (o.geometry.attributes.position?.count || 0) / 3;
          tris += triCount;
        }
      });
  // `bim-label` is a custom element; use `textContent` so the visible label updates
  // even if the element doesn't implement a `value` property.
  statsLabel.textContent = `Meshes: ${meshes.toLocaleString()} • Tris: ${tris.toLocaleString()}`;
    }
  </script>
</body>
</html>
